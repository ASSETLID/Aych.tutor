<h3>Pattern-matching on lists</h3>

<p>
 However, the real power of pattern-matching appears when we start
 using more structured values, when we start needing giving a name to
 matched patterns. For instance, a list is either the empty
 list <pre>[]<pre> or a head and a tail, denoted by the
 pattern <pre>h::t</pre> where <pre>h</pre> and <pre>t</pre> are fresh
 variables bound to the matched patterns (we can still
 use <pre>_</pre> to discard unused variables):

<code>let head = function
  | []   -> failwith "empty list"
  | h::_ -> h
</code>

More complex patterns can be written, for instance to look at the head
of the tail:

<code>let second_element = function
  | []      -> failwith "the list is empty"
  | [_]     -> failwith "the list contains only one element"
  | _::e::_ -> e
</code>

Or to look deeper into the matched list:

<code>let head_head = function
  | []        -> failwith "the list is empty"
  | [[]]::_   -> failwith "the head is the empty list"
  | [h::_]::_ -> h
</code>
</p>

