###lesson:Syntax traps
###step:Sequence of expressions

<p>It is easy to get confused by OCaml syntax since it's different from
mainstream languages. So you'd better be aware of a few things before digging
any deeper.</p>

<br />
<p>To begin with, you should know that a proper command must normally ends with
<em>';;'</em> to be processed by the top-level.  This tutorial automatically adds
the double semicolon as soon as you hit enter but the normal top-level won't.
The double semicolon is only required when interacting with the top level
interpreter and as such is not part of OCaml syntax.</p>

<br />
<p>What <em>is</em> part of OCaml syntax, though, is the simple semicolon
<em>';'</em> which is commonly used as an expression terminator, except that in
OCaml it's a <b>separator</b>.  In other words, you must not write <code>expr1;
expr2;</code> but <code>expr1 ; expr2</code>.</p>

<br/ >
<p>You may now enter <code>next ()</code> to check your understanding.</p>
###test:
fun input output ->
  false
###step:Exercise: Get the Punctuation Right!

<p>Let's see if you got this right. Here is a sequence of <strong>erroneous</strong>
commands. Your task is to fix all of them in order to get the correct
answer at the end.</p>
<br />
<p><code>let fernand = "King of Castille";</code></p>
<br/>
<p><code>let rodrigue = "The cid"; let diegue = "cid's father"</code></p>
<br/>
<p><code>characters = [ fernand;; rodrigue;; diegue ]</code></p>
<br/>
<p><code>rodrigue.[4] <- 'C' ; diegue.[0] <- rodrigue.[4] ;</code></p>
<br/>
<p><code>characters</code></p>

###test:
fun input output ->
  find_in "characters" input &&
  output = "- : string list = [\"King of Castille\"; \"The Cid\"; \"Cid's father\"]\n"
###step:The <em>let</em> keyword

<p>The other source of confusion for newcomers is the <em>let</em> keyword
which acts differently in the toplevel than in normal OCaml expressions.</p>
<br />

<p>In the toplevel <code>let x = 1</code> binds the name <code>x</code> to the
integer 1 as seen in <code>lesson 2</code>. If <em>x</em> was already bound to something
it's previous binding is lost:</p>
<code>let x = "I am now a string!"</code>
<br /><br />

<p>The <em>let</em> keyword is also used to form an expression in which a name
is given to some value temporarily, for the evaluation of a subexpression only:<br />
<code>let x = 41 in x + 1</code><br />

 The value of <em>x</em> is <em>41</em> during
the evaluation of <em>x + 1</em> only; the global binding of <em>x</em> to
<code>"I am now a string!"</code> is preserved.</p>
<br />

<p>See what <code>x</code> is evaluated to now, and type <code>next ()</code>
for a little practice.</p>
###test:
fun input output ->
  false
###step:Exercise: let there be lets!

<p>Fix all these <em>let</em> expressions in order to get the expected result
at the end:</p>

<pre><code>let xy =
  let x = 'x' and let y = 'y' in x ::[y]</code></pre>

<pre><code>let ab =
  let a = 'a'
  let b = 'B' in Char.lowercase b
  in a ::[b]
</code></pre>

<pre><code>let up = Char.uppercase in
  big_xy = List.map up xy ;
  big_ab = List.map up ab ;
  big_ab @ big_xy</code></pre>
###test:
fun input output ->
  find_in "Char.uppercase" input &&
  output = "- : char list = ['A'; 'B'; 'X'; 'Y']\n"
###step:Parentheses

<p>With regard to grouping expression or enforcing order of evaluation,
OCaml syntax is surprisingly easy: you can use pervasively either parentheses
or <em>begin</em>/<em>end</em> keywords.</p>
<br />
<p>Example grouping expressions in an <em>if</em> form:</p>
<pre><code>if 1+2 = 3 then (
  print_string "did you knew that?\n" ;
  print_string "amazing!\n"
)
</code></pre>

<p>Or forcing order of evaluation with <em>begin</em>/<em>end</em> (although
you won't find this often!):</p>
<code>begin 1 + 2 end * 3</code>

<br /><br />
<p>Also, as function application takes precedence over infix operators you will
frequently uses parentheses to make explicit the expected evaluation order, as
in: <code>square (1 + 1)</code> since <code>square 1+1</code> would yield
<em>2</em>.

<p>Enter <code>next ()</code> when you are ready to practice.</p>
###test:
fun input output ->
  false
###step:Exercise: Fix the grouping

<p>A Lisp programmer stole all our parentheses!
Get them back in order to get the proper result at the end.</p>

<pre><code>let ten =
  let double x = x+x in
  double 3 + 2</code></pre>

<pre><code>let hundred =
  if true or false then
    print_string "May I help you?\n" ;
    100
  else 0</code></pre>

<pre><code>let one =
  let accum = ref -54 in
  for i = 1 to ten do accum := !accum + i done ;
  !accum </code></pre>

<pre><code>one + match hundred with
  | 42  -> match ten with 10 -> 52  | _ -> 0
  | 100 -> match ten with 10 -> 110 | _ -> 0
</code></pre>

###test:
fun input output ->
  find_in "match" input && output = "- : int = 111\n"
