###lesson:Imperative Programming
###step:Variables

<p>As in other languages, you can associate a name to a value. To do
that, we use the <code>let</code> syntax which associates the result
of some computation with a name:</p>

<p><code>let x = 6 * 7</code></p>

<br />

<p>We can now check the value associated with <code>x</code> in the
toplevel:</p>
<p><code>x</code></p>

<br />
<p>And we can use the name where we would like the value:</p>
<p><code>let y = x + 1</code></p>

###test:

fun input output -> find_in "val y : int = 43" output

###step:Mutable Variables

<p>In OCaml, you cannot change the value associated with a name after
its definition. Trying to do so will trigger a compilation error:</p>
<p><code>x <- x + 1</code></p>

<p>You will better understand the error message later.</p>

<br />
<p>If you really want to modify the value associated with a name, you
must use a trick. OCaml provides a function <code>ref</code> that
creates a special value that can be modified later (a reference):</p>
<p><code>let x = ref 42</code></p>

<br />
<p>You can then change the value of the reference associated
with <code>x</code> using the <code>:=</code> operator:</p>
<p><code>x := 100 / 4</code></p>

<br />
<p>You can also access the value contained in the reference using the
operator <code>!</code>:</p>

<p><code>let y = !x + 1</code></p>

###test:

fun input output ->
  find_in " : int = " output && find_in " !" input

###step:Sequences and Printing

<p>OCaml provides different functions to print basic types. For
example:</p>

<p><code>print_int 3</code></p><br/>

<p>and:</p>

<p><code>print_string "Hello"</code></p><br/>

<p>Sequences of expressions are separated by <code>;</code>:</p>

<pre><code>print_string "x = ";
print_int !x;
print_newline ()</code></pre>

<p>A more powerful method to print values
is <code>Printf.printf</code>, whose behavior is similar
to <code>printf</code> in C:</p>

<p><code>Printf.printf "x = %d. Bye %s\n" !x "John"</code></p>

<br/>

###test:

fun input output ->
  find_in " : unit = " output && find_in "Printf.printf" input

###step:For loops

<p>Let's define a reference on a list:</p>

<p><code>let xl = ref []</code></p>
<br/>

<p>OCaml provides a simple <code>for</code> loop to iterate on
integers in a range:</p>

<pre><code>for i = 1 to 10 do
  xl := i :: !xl;
done;
!xl
</code></pre><br/>

<p>Here, for each value between 1 and 10, we have added it in this
order at the head of the reference.</p>

<p>Of course, if we want them in the correct order, we need to reverse
the list:</p>

<p><code>List.rev !xl</code></p>
<br/>
<p>Or we can just execute the loop directly from the upper bound to the
lower bound:</p>

<pre><code>for i = 10 downto 1 do
 xl := i :: !xl
done;
!xl</code></pre>
<br/>

<p>
###test:
fun input output ->
  find_in "4; 5" output && find_in " downto" input

###step:Computing Conditions

<p>Boolean values in OCaml can be either <code>true</code>
or <code>false</code>. They are often created from comparing other
values. For example:</p>

<p><code>1 &gt; 2</code></p>
<br />

<p>OCaml's comparison operators can be used on values of any type,
not only on numerical values. We can compare strings and characters
too:</p>

<p><code>"aaaaaa" &lt; "bbb"</code></p>
<p><code>"3" &lt;= "22"</code></p>
<p><code>22 &gt;= 3</code></p>
<br />

<p>To test equality, you can use <quote>=</quote>, and for inequality, there
is <quote>&lt;&gt;</quote>. For example:</p>

<p><code>1 = 1</code></p>
<p><code>1 &lt;&gt; 1</code></p>
<p><code>"1" = 1</code></p>

<br />

<p>Oops, OCaml does not allow you to compare values with different
types, so we must be more careful:</p>

<p><code>"1" = string_of_int 1</code></p>
###test:
fun input output ->
  find_in "string_of_int" input && find_in "- : bool" output
###step:If then else

<p>Now that we know how to test conditions, we can use them to choose
between computations. Let's define two values : </p>

<p><code>let a = 1 and b = 2</code></p><br/>

<p>We can compute the minimum of them:</p>

<pre><code>Printf.printf "min(%d,%d) = %d\n" a b
    (if a &lt; b then a else b)</code></pre><br/>

<p>We can of course execute sequences within branches:</p>

<pre><code>let z = if a &lt; 100 then begin
    print_string "return at least 100 !";
    print_newline ();
    100
 end else a
</code></pre>
###test:
fun input output ->
  find_in " : int = 100" output


###step:While loops

<p>OCaml also provides a <code>while</code> loop, to execute some code
as long as an expression is true:</p>

<pre><code>while !x &gt; 20 do
  print_int !x; print_newline ();
  x := !x - 2
done</code></pre>

<!---
<p>For example, the following code will wait for you to say "yes":</p>

<pre><code>let cond = ref true;;
while !cond do
  print_string "Say 'yes':";
  cond := ( input_line stdin <> "yes" )
done;;
</code></pre>
--->
###test:
fun input output ->
  find_in "while" input

###step:Congratulations

<p>You have seen that OCaml allows you to use some imperative style of
programming. Some functional programmers will tell you that
side-effects are bad: they are right, in many cases, but don't listen
to them too early !</p>


<p>In the next lessons, you will see that by combining both imperative
and functional programming styles, you can do wonders !</p>

<p>Use <code>next()</code> to go to the next lesson !</p>

###test:

fun input output ->
  find_in " : unit" output && find_in "next" input

